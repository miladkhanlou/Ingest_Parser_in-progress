Part 1, Debug xml2workbench to read data:
==========================================
1) 'NoneType' object has no attribute 'text':
    a.	Assigned the whole titleInfo.find('subTitle', ns) into a variable
    b.	checked if subTitle AND subTitle.text is None or not
    c.	if not none it will write text within the tytleInfo  into the 'text' variable 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2)	'NoneType' object has no attribute 'lower'"
    a. we need to specify changes only to the genre tags that are not None
    b. So we create an if inside for loop on genres in genres xml_genres (line 171) to say insert genres to genres empty list if the genre in xml_genres and xml_genres.text is not None
    c. I created a genretet = genre.text to ease of use in tmp variable.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3)  data['field_place_published'] = '|'.join(data['field_place_published']) line 252 ===> sequence item 0: expected str instance, NoneType found:
    a.	field_place_published name chanege to field_place_of_publication
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4) UnicodeEncodeError: 'charmap' codec can't encode character '\u0301' in position 194: character maps to <undefined>
    -   This error happens when saving scraped web content to a file. To fix it add encoding="utf-8" to open function:
          >> with open(fname, "w", encoding="utf-8") as f:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

part 2, Debug Wrong data on csv2workbench:
==========================================
1) Field_Full_title did not give us the right output:
	Wrong data -->  Subtitle of this item : Subtitle of this item
	Corret data --> The Title of this item : Subtitle of this item
	
	Steps to fix it:
		1. Go to line 45, in the MODS SECTION PARSING
		2. move the concat_title_parts functoin before parseTitleInfo function
		3. In the the concat_title_parts function:
		***	concat_title_parts is just a text that creates TITLE:SUBTITLE form to show title and subtitle.
			a. non_sort part: (nonSort tag in xml is will be written beside the title tag, like The, an or etc.) ==> Code is currect creates 'the ' and after this title comes
			b. add the if statement for title tag which was missing in xml2workbench code:
				i. add codes to gets the attrebute 'title' and adds to the text==> Output in this part will be 'The title of this item'
					>>>	title = titleInfo.find('title', ns) #To find title tags in xml and put it in title
					>>>	if title is not None and title.text is not None:
					>>>		text += title.text
					>>>		# text += ' : ' #This line should be after "text += title.text" 

				ii. commented the nonType variable part as in the next oart we have subtitle variable that finds the 'subTitle attribute' in xml just like nonType variable.
					- The difference between nonType and subtitle variable is:
						--> text schema in nonTyoe is like --> text += nonType.text   
						--> text schema in subTitle is like -->  text += ' : ' ---------> text += subtitle.text ####This is what we want for subtitle
					>>>	nonType = titleInfo.find('subTitle', ns)
					>>>	if nonType is not None and nonType.text is not None:
					>>>		text += nonType.text  
					
				iv. delete or comment out the " text += ' : '" in the if stetement for 'subtitle' As we do not have any more info after subtitle.
				
		4. Add the right data with parseTitleInfo functoin and changes:
			> Describe code for parseTitleInfo function:
				- title varialble finds titleInfo attributes and put them in titles variable ====> titles = root.findall('titleInfo', ns)
				- data is a dictionary, keys are title, field_alt_title(list of alternatives), field_full_title ===> data = {'title': '', 'field_alt_title': [], 'field_full_title': ''} 
				- For loop loops into each titleInfo to:
					a. If we did not have 'type' tag: 
					in concat_title_parts(title) -> text created using concat_title_parts that looks like: text= text in title attribute 'The Title of This Item ' ==> and will add the sting as a title of the item (Webpage)
						i. it adds the what we got from concat_title_parts output to data[title] and data['field_full_title'] 
							==> for title: We add split to output of concat_title_parts output which is the full title/subtitle : data['title'] = concat_title_parts(title).split(" : ")[0]
							==> for field_full_title: data['field_full_title'] = data['title'] ==> which is full title/subtitle.
						ii. Creates data for 'field_full_title' AND 'title' fields.
					b. if there was a 'type' tag in titleInfo attribute (title.get('type') we have to add must add logicsto add as many types as we have in LDL (like alternative,abbreviated,uniform, etc.)
						- logic will look like this:
						--> if title.get('type') == 'X' ----Then----> add that .text of X tag to text variable in concat_title_parts function and append it to field_alt_title list
					c. add the End will use pipe ' | '. join() to join all these 'field_alt_title's 
				
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2) field_alt_title: did not give us all the alternative titles types such as: Translated title/subtitle | Translated title/subtitle | Uniform title/subtitle | Abbreviated title/subtitle
	(all of the titles types shoud be mentioned in one row with pipe seperated form)
	1. Go to the line where parseTitleInfo function exists.
	2. Add more logics to add additional types types because the code reads all the types and append it to concat_title_parts in for loop for titles
	***	concat_title_parts is just a text that creates "TITLE:SUBTITLE" form to show title and subtitle. 
		a. Using the output from concat_title_parts in parseTitleInfo function if there us any 'type' tags (title.get('type'):
		b. We must add more logics to add as many types as we have in LDL (like alternative,abbreviated,uniform, etc.)
		- logic will look like this:
		--> if title.get('type') == 'X' ----Then----> add that .text of X tag to text variable in concat_title_parts function and append it to field_alt_title list
		c. add the End will use pipe ' | '. join() to join all these 'field_alt_title's  
		=====> Output: Translated title/subtitle | Translated title/subtitle | Uniform title/subtitle | Abbreviated title/subtitle
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3) Add and customize the way it parses data:
	1) Some columns needed to be droped from the metadata 
		( field_classification, field_copyright_date, field_dewey_classification, field_edition, field_is_preceded_by, field_is_succeeded_by, field_isbn, field_lcc_classification,
		field_linked_agent,field_local_identifier, field_mode_of_issuance, field_note, field_oclc_number,field_physical_form,field_pid,field_place_of_publication, 
		field_place_of_publication_country, field_resource_type, field_rights, field_subject, field_subjects_name, field_table_of_contents )
	
	2) No mapping:
	- There were no functions and logics that go to tags within tags (children) and get the text according to the attributes
	- In child tags, different texts in different attrebutes need to be placed into different columns -> some of columns do not exist and some needed to be renamed
	Fields to be mapped:
		a. Part
			i. three fields added to general dictionary
			ii.	itered to Part tag
			iii. writing the text in child tags according to the child's tag name
		b. recordInfo (NO NOTES FROM ELISA YET)
		c. Location
			i.	5 fields added to data dictionary
			ii.	pars to 'location' tag
			iii. if child tag's name was 'physicalLocation' >>> if child's tag's names's attribute was 'Physical Location' or 'OCLC Member Symbol' write data accordingly
			iv. if child tag's name was 'subLocation' >>> write text in that child tag to field_subLocation
			v. if child tag's name was 'shelfLocator' >>> write text in that child tag to field_shelf_location
			vi. added 'xml_data.update(parsLocation(root))' line to parse_mods function to write it to xml_data dict to finalize addinf process

	3) Missing data because of no child tags parsing to get the texts:
		a. there were no mapping tags within tags
			-There were no functions and logic that go to tags within tags (children) and get the text according to the attrebute
			i. parseOriginInfo
			
			ii. parsePhysicalDescription: separate the abstract data into 5 fields(Fields added):
				a.	added data to different Fields according to Children Tags
			
			iii. ParseAbstract:	separate the abstract data into two fields:
			Originally in Rosie's code all the data would go into data dictionary and from there joined to 'field_abstract'
				a.	field_harmful_content_notice (IS IN ELISA'S NOTES BUT IT IS NOT IN XML ABSTARCT)
				b.	field_bastract_description (IS NOT IN ELISA'S NOTES BUT IT IS IN XML ABSTARCT)
			
			iv. parseRelatedItem:
			New logics to add a few fields by parsing into tags, child tags, get the text eccouridng to the tag's attribute --> for host attributes
				a. Iter to all the tags within the relatedItem with tag==host
				b. if tag name was titleInfo:
					>>> if displayLabel attribute of the wihin tag was 'Parent Item Title' >>> get to the tag within it and put the text in 'field_parent_Item_Title' field (IS IN ELISA'S NOTES BUT IT IS NOT IN XML)
					>>> if displayLabel attribute of the wihin tag was 'Digital Collection' >>> get to the tag within it and put the text in 'field_digital_collection' 
					>>> if displayLabel attribute of the wihin tag was 'Repository Collection' >>> get to the tag within it and put the text in 'field_repository_collection' 
				c. if tag name was location:
					>>> if displayLabel attribute of the wihin tag was 'Relation' >>> get to the tag within it and put the text in 'field_digital_collection_url' 
					>>> if displayLabel attribute of the wihin tag was 'Repository Collection Guide' >>> get to the tag within it and put the text in 'field_digital_collection_url' 
			
			v. parseAccessCondition: 5 fields added insteaed of field_rights: Changed the code and logic to itering to tags and attributes
			(NOTE FOR ELISA: 'xlink:href' is not recognized as attribute, Could not write it to column field_rights_statement_uri)
				a. wtote the data within accessCondition according to the child tag's attributes
				
			vi. namePart (parseNameInfo function)
				
				